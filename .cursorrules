# ğŸ¤– Cursor Agent Quick Reference

## ğŸ“ START HERE - Agent Orientation

### On Every New Context:
1. **Read:** `.github/PROJECT_STATUS.md` (current phase, open issues)
2. **Check:** `python3 .github/workflows/scripts/read_issues.py --list --state open`
3. **Understand:** Read relevant section of `archive/PACKAGE_CONVERSION_PLAN_RU.md` (if needed)
4. **Check Git Branch:** Verify not on `main` branch (see Git Workflow below)
5. **Act:** Follow issue checklist or user request

### When User Says "Continue Work":
```bash
# Auto-workflow:
1. Check PROJECT_STATUS.md â†’ current phase
2. List open issues â†’ identify active issue
3. Read issue details â†’ understand task
4. Check plan context â†’ understand why
5. Check current branch â†’ ensure on feature branch
6. Implement â†’ follow issue acceptance criteria
7. Commit â†’ use conventional commits format
```

## ğŸ¯ Project Context (Quick Facts)

**Project:** telegram-bot-stack (reusable Telegram bot framework)
**Current Phase:** Phase 2 - PyPI Publication (Next)
**Repository:** https://github.com/sensiloles/telegram-bot-stack
**Master Plan:** `archive/PACKAGE_CONVERSION_PLAN_RU.md` (archived)

**Progress:**
- âœ… Phase 0.1: Extract framework â†’ telegram_bot_stack/
- âœ… Phase 0.2: Tests (111 tests, 81% coverage)
- âœ… Phase 0.3: Validation & docs
- âœ… Phase 1: PyPI package structure (131 tests, 80% coverage)
- â³ Phase 2: PyPI publication (next)

## ğŸ“š Quick Navigation

| Need | File | Lines |
|------|------|-------|
| Project status | `.github/PROJECT_STATUS.md` | All |
| Dependency graph | `.project-graph/dependency-graph.json` | All |
| Graph utilities | `.project-graph/graph_utils.py` | All |
| GitHub automation | `.github/workflows/scripts/README.md` | All |
| Master plan (archived) | `archive/PACKAGE_CONVERSION_PLAN_RU.md` | All |
| Architecture | `README.md` | 155-250 |
| Testing guide | `README.md` | 80-154 |
| Git workflow | This file | 50-80 |

## ğŸ”„ Essential Workflows

### Git Workflow (IMPORTANT!)

**âš ï¸ CRITICAL: We use GitHub Flow with branch protection!**

#### For Agent: Optimal Git Workflow

**Rule 1: NEVER push directly to `main`**
- `main` branch is protected
- Direct pushes will be rejected
- Always work in feature branches

**Rule 2: Always check current branch**
```bash
# Before making changes:
git branch --show-current
```

**Rule 3: Create feature branch if needed**
```bash
# If on main or need new feature:
git checkout -b feature/<descriptive-name>
# Or:
git checkout -b fix/<bug-name>
git checkout -b docs/<doc-name>
```

**Rule 4: Make changes and commit**
```bash
# Standard workflow:
1. git status && git diff --stat
2. git log --oneline -5                     # Check commit style
3. Update docs BEFORE commit (if needed)
4. git add .
5. git commit -m "type(scope): description" # Conventional commits!
```

**Rule 5: Push to feature branch with upstream**
```bash
# First push - set upstream tracking:
git push -u origin feature/<name>

# Subsequent pushes (upstream already set):
git push
```

**Rule 6: Create PR automatically (PREFERRED)**

**Method:** Use automation script after push
```bash
# Push changes first (with upstream tracking)
git push -u origin feature/<name>

# Then create PR automatically
python3 .github/workflows/scripts/create_pr.py \
--title "type(scope): description" \
--closes N                                       # if working on issue
```

**Benefits:**
- âœ… Validates conventional format automatically
- âœ… Auto-generates description from commits
- âœ… Links to issue with --closes N
- âœ… Creates PR instantly (no manual steps)
- âœ… Notifies user with PR URL
- âœ… Auto-assigns PR to you

**Rule 7: Merge PR (ONE COMMAND!)**

**âš¡ SIMPLIFIED MERGE - Use this method!**

```bash
# One-command merge (auto-detects PR, merges, switches to main, pulls)
python3 .github/workflows/scripts/merge_pr.py

# With cleanup (deletes both local and remote feature branches)
python3 .github/workflows/scripts/merge_pr.py --cleanup
```

**What it does automatically:**
1. âœ… Detects PR number from current branch
2. âœ… Merges PR with squash (clean history)
3. âœ… Switches to main branch
4. âœ… Pulls latest changes
5. âœ… Optionally deletes local AND remote branches (with --cleanup)
6. âœ… Shows release status info

**Other options:**
```bash
# Merge specific PR number
python3 .github/workflows/scripts/merge_pr.py --pr 42

# Dry run (preview what would happen)
python3 .github/workflows/scripts/merge_pr.py --dry-run

# Merge without switching to main
python3 .github/workflows/scripts/merge_pr.py --no-switch
```

**OLD COMPLEX WAY (DON'T USE):**
- âŒ Finding PR number manually
- âŒ Multiple git commands
- âŒ Checking release status separately
- âš ï¸ Too many steps, error-prone

**USE THE NEW WAY:** Just run `merge_pr.py` and everything happens automatically! ğŸ‰

### Conventional Commits (REQUIRED!)

**Format:** `type(scope): description`

**Version Impact:**
- `feat:` â†’ MINOR version bump (0.1.0 â†’ 0.2.0)
- `fix:` â†’ PATCH version bump (0.1.0 â†’ 0.1.1)
- `docs:` â†’ No version bump
- `chore:` â†’ No version bump
- `test:` â†’ No version bump
- `refactor:` â†’ No version bump
- `perf:` â†’ PATCH version bump
- `feat!:` or `BREAKING CHANGE:` â†’ MAJOR version bump (0.x.x â†’ 1.0.0)

**Examples:**
- `feat(storage): add Redis backend support`
- `fix(auth): resolve token validation issue`
- `docs(readme): update installation instructions`
- `test(storage): add integration tests`
- `chore(deps): update dependencies`
- `refactor(bot): simplify command handling`

### Agent Decision Tree for Git Operations

```
START
â†“
Is this documentation-only change?
â”œâ”€ YES â†’ Use `docs:` commit type â†’ No version bump
â”œâ”€ NO â†’ Continue
â†“
Is this a new feature?
â”œâ”€ YES â†’ Use `feat:` commit type â†’ MINOR bump
â”œâ”€ NO â†’ Continue
â†“
Is this a bug fix?
â”œâ”€ YES â†’ Use `fix:` commit type â†’ PATCH bump
â”œâ”€ NO â†’ Continue
â†“
Is this maintenance/chores?
â”œâ”€ YES â†’ Use `chore:` commit type â†’ No bump
â”œâ”€ NO â†’ Use best judgment
â†“
COMMIT â†’ PUSH â†’ CREATE PR AUTOMATICALLY
```

### GitHub Issues & PRs (Use Scripts)

**Issues:**
```bash
# List open issues
python3 .github/workflows/scripts/read_issues.py --list

# Read specific issue
python3 .github/workflows/scripts/read_issues.py 4

# Create issue from file
python3 .github/workflows/scripts/create_issue.py \
--title "Bug: Fix issue" \
--file /tmp/issue.md \
--labels bug,priority:high
```

**Pull Requests (AUTOMATED! ğŸ‰):**
```bash
# Auto-create PR (preferred method)
python3 .github/workflows/scripts/create_pr.py \
--title "feat(storage): add Redis backend" \
--closes 42

# Draft PR (WIP)
python3 .github/workflows/scripts/create_pr.py \
--title "feat: WIP feature" \
--draft

# Preview before creating
python3 .github/workflows/scripts/create_pr.py \
--title "feat: feature" \
--dry-run
```

**See:** `.github/workflows/scripts/README.md` and `.github/PR_AUTOMATION.md` for complete guides.

### Testing
```bash
# Run tests
python3 -m pytest

# With coverage (threshold: 80%)
python3 -m pytest --cov=src/core --cov-report=term

# CI/CD: .github/workflows/tests.yml
```

## âš¡ Critical Rules

### Security
- **NEVER** commit tokens/passwords
- Use `.env` (must be in `.gitignore`)
- Validate tokens at startup

### Code Quality
- All comments/docstrings in **English**
- Use type hints for all new code
- Follow `ruff` linting rules
- Remove unused imports/code immediately

### Documentation
- **UPDATE existing docs**, don't create new ones
- **NEVER create *.md files** unless critically necessary
- Describe work in chat, not in documents
- Keep chat descriptions concise and clear
- Update docs **BEFORE** committing code
- **UPDATE dependency graph** when changing `telegram_bot_stack/` structure (see Graph Maintenance below)
- Keep examples executable
- Verify instructions work "out of the box"

### Testing
- Maintain â‰¥79% coverage for `telegram_bot_stack/`
- Write tests for all new features
- Use fixtures from `tests/conftest.py`

## ğŸ—‚ï¸ Project Structure

```
telegram-bot-stack/
â”œâ”€â”€ telegram_bot_stack/   # PyPI package (coverage 80%)
â”‚ â”œâ”€â”€ bot_base.py       # Base class with hooks
â”‚ â”œâ”€â”€ storage/          # Storage abstraction layer
â”‚ â”‚ â”œâ”€â”€ json.py       # JSON backend
â”‚ â”‚ â””â”€â”€ memory.py     # Memory backend
â”‚ â”œâ”€â”€ user_manager.py
â”‚ â””â”€â”€ admin_manager.py
â”œâ”€â”€ examples/             # Example bots
â”‚ â”œâ”€â”€ echo_bot/
â”‚ â”œâ”€â”€ counter_bot/
â”‚ â””â”€â”€ quit_smoking_bot/
tests/
â”œâ”€â”€ core/                 # Unit tests
â””â”€â”€ integration/          # E2E tests
```

## ğŸ’¡ Tips for Token Efficiency

**DON'T read entire files unnecessarily:**
- Use `codebase_search` for understanding
- Use `grep` for finding specific code
- Read specific line ranges: `read_file` with offset/limit
- **Use dependency graph** for understanding module relationships

**DO read these on start:**
- `.github/PROJECT_STATUS.md` (compact status)
- `.project-graph/dependency-graph.json` (if working on architecture/refactoring)
- Current issue via script (structured output)
- Relevant plan section only (not entire file)
- `git branch --show-current` (verify branch)

**Prioritize:**
1. Check git branch â†’ ensure on feature branch
2. Status file (20 lines) â†’ context
3. Dependency graph (if architecture work) â†’ relationships
4. Issue details (50-100 lines) â†’ task
5. Plan section (50-100 lines) â†’ why
6. Code only when needed â†’ implementation

**Use Dependency Graph for:**
- Understanding module dependencies before refactoring
- Finding impact of changes (check `dependents` field)
- Locating functionality (check `ai_agent_hints.common_tasks`)
- Understanding design patterns used
- Finding extension points

## ğŸ¯ Agent Optimization Strategies

### When to Create Feature Branch

**Create new branch IF:**
- Currently on `main` branch
- Starting work on new issue/feature
- User says "continue work" and no feature branch exists

**Stay on current branch IF:**
- Already on a feature branch
- Continuing work on same feature
- Branch name matches the work being done

**Branch Naming:**
- `feature/<issue-number>-<short-description>` (e.g., `feature/5-add-redis`)
- `fix/<issue-number>-<short-description>` (e.g., `fix/23-auth-bug`)
- `docs/<description>` (e.g., `docs/update-api-reference`)

### Optimal Commit Strategy

**Single logical change:**
- Make one commit per logical unit of work
- Example: "Add Redis storage backend" (not "Add Redis" + "Add tests" as separate commits)

**Batch related changes:**
- Group related file changes in one commit
- Example: Update README + add example + update docs â†’ one `docs:` commit

**Multiple features in session:**
- If working on multiple unrelated things, ask user:
- "Should I commit feature A before starting feature B?"
- "Should I create separate branches for each feature?"

### When to Push and Create PR

**Push and auto-create PR after:**
- Completing a logical unit of work
- User asks to "commit" or "save"
- Completing issue checklist item
- Before switching to different task

**Workflow:**
```bash
# 1. Push changes (set upstream on first push)
git push -u origin feature/xyz

# 2. Auto-create PR with script
python3 .github/workflows/scripts/create_pr.py \
--title "type(scope): description" \
--closes N                                       # if working on issue
```

**Notify user with success message:**
```
âœ… Changes committed to branch `feature/xyz`
ğŸ“ Pushed to origin/feature/xyz
ğŸ¤– Pull Request created automatically!
Number:                                       #10
URL: https://github.com/owner/repo/pull/10

Details:
- Title: type(scope): description
- Issue:                            #N (auto-closes on merge)
- CI checks: Running automatically
- Status: Ready for review
- Assignee: Auto-assigned to you
- Release: Will trigger after merge
```

### When to Merge PR (SIMPLIFIED!)

**Merge PR when:**
- User says "merge", "Ğ´Ğ°Ğ²Ğ°Ğ¹ Ğ¼ĞµÑ€Ğ´Ğ¶Ğ¸Ñ‚ÑŒ", "merge it"
- Work is complete and ready for release
- All CI checks passed (script will check)

**âš¡ ONE COMMAND MERGE:**
```bash
# Just run this (auto-detects everything)
python3 .github/workflows/scripts/merge_pr.py
```

**What happens automatically:**
1. Finds PR for current branch
2. Merges with squash method
3. Switches to main branch
4. Pulls latest changes
5. Optionally deletes branches (with --cleanup)
6. Shows release status

**With cleanup:**
```bash
# Deletes both local and remote feature branches
python3 .github/workflows/scripts/merge_pr.py --cleanup
```

**Notify user with:**
```
âœ… PR                                             #X merged successfully!
ğŸ”„ Switched to main branch
ğŸ“¥ Pulled latest changes
ğŸš€ Release workflow started automatically
ğŸ’¡ Tip: New version will be tagged automatically
```

**DON'T:**
- âŒ Manually find PR number
- âŒ Use multiple git commands
- âŒ Manually switch branches
- âŒ Check release status with API calls
- âš ï¸ The script does all of this automatically!

### Emergency: If on main branch

**If you accidentally made changes on main:**
```bash
# 1. Check current state
git status

# 2. Create feature branch (takes changes with it)
git checkout -b feature/emergency-branch-name

# 3. Commit on feature branch
git add .
git commit -m "type: description"

# 4. Push feature branch (set upstream)
git push -u origin feature/emergency-branch-name

# 5. Inform user
```

## ğŸš¨ Critical Git Rules for Agent

1. **NEVER push to `main`** - Will fail due to branch protection
2. **ALWAYS check branch** before making changes
3. **ALWAYS use conventional commits** - Enables auto-versioning
4. **AUTO-CREATE PRs** - Use `create_pr.py` script (auto-assigns to you)
5. **ONE-COMMAND MERGE** - Use `merge_pr.py` (auto-detects PR, switches to main)
6. **BATCH commits** - One commit per logical unit, not per file
7. **UPDATE docs** before committing code changes
8. **UPDATE dependency graph** before committing code changes (if needed)
9. **RUN tests** before pushing (if applicable)

**Quick Merge Command:**
```bash
python3 .github/workflows/scripts/merge_pr.py
```
This ONE command does everything: find PR, merge, switch to main, pull!

## ğŸ“Š Dependency Graph Maintenance

### When to Update the Graph

**ALWAYS update `.project-graph/dependency-graph.json` when:**
- âœ… Adding new modules to `telegram_bot_stack/`
- âœ… Removing modules from `telegram_bot_stack/`
- âœ… Changing module dependencies (imports)
- âœ… Adding/removing public API (exports in `__init__.py`)
- âœ… Refactoring module structure
- âœ… Changing design patterns implementation

**NO need to update for:**
- âŒ Changes in tests/ directory
- âŒ Changes in examples/ directory
- âŒ Documentation-only changes
- âŒ Changes in .github/ directory
- âŒ Bug fixes that don't change dependencies

### How to Update the Graph

**Step 1: Identify changes**
```bash
# Check what files changed
git status
git diff --name-only

# If telegram_bot_stack/ files changed, update graph
```

**Step 2: Update graph structure**
```bash
# Edit .project-graph/dependency-graph.json

# Key sections to update:
# 1. nodes[] - add/remove/modify node entries
# 2. edges[] - add/remove dependency edges
# 3. metadata.generated_at - update date
# 4. metadata.node_count - if nodes changed
# 5. metadata.edge_count - if edges changed
# 6. statistics - recalculate if major changes
```

**Step 3: Validate graph**
```bash
cd .project-graph
python3 graph_utils.py     # Should show "âœ… Graph is valid!"

# Or run validation only
python3 -c "from graph_utils import load_graph, validate_graph; g=load_graph(); print(validate_graph(g))"
```

**Step 4: Test graph utilities**
```bash
# Quick test
cd .project-graph
python3 examples.py | head -50
```

### Update Examples

**Example 1: Added new storage backend `redis.py`**
```json
// 1. Add node
{
"id": "telegram_bot_stack.storage.redis",
"name": "storage.redis",
"type": "module",
"category": "implementation",
"path": "telegram_bot_stack/storage/redis.py",
"description": "Redis-based storage backend",
"lines_of_code": 150, // Count lines
"complexity_score": 5, // Estimate 1-10
"exports": ["RedisStorage"],
"imports": {
"internal": ["storage.base.StorageBackend"],
"external": ["redis", "logging"]
},
"dependencies": ["telegram_bot_stack.storage.base"],
"dependents": ["telegram_bot_stack.storage"],
"tags": ["implementation", "storage-backend", "redis"],
"role": "Redis storage backend for distributed bots",
"criticality": "medium"
}

// 2. Add edges
{
"id": "edge_15",
"source": "telegram_bot_stack.storage.redis",
"target": "telegram_bot_stack.storage.base",
"type": "implements",
"strength": 5,
"description": "Implements StorageBackend interface",
"relationship": "inheritance",
"bidirectional": false
}

// 3. Update storage/__init__.py node
// Add "telegram_bot_stack.storage.redis" to its dependencies

// 4. Update metadata
{
"metadata": {
"node_count": 9, // was 8
"edge_count": 16, // was 14
"generated_at": "2025-11-17" // today
}
}
```

**Example 2: Refactored BotBase to use new component**
```json
// Update BotBase node:
{
"id": "telegram_bot_stack.bot_base",
// ... existing fields ...
"dependencies": [
"telegram_bot_stack.admin_manager",
"telegram_bot_stack.user_manager",
"telegram_bot_stack.storage.base",
"telegram_bot_stack.new_component" // ADD THIS
],
"complexity_score": 9 // was 8, increased
}

// Add new edge
{
"source": "telegram_bot_stack.bot_base",
"target": "telegram_bot_stack.new_component",
"type": "uses",
"strength": 3,
"description": "Uses NewComponent for X functionality"
}
```

### Pre-Commit Checklist

Before committing changes to `telegram_bot_stack/`:

```bash
# 1. Check branch
git branch --show-current # Should NOT be main

# 2. Check what changed
git status
git diff telegram_bot_stack/

# 3. If telegram_bot_stack/ changed â†’ update graph
# Edit .project-graph/dependency-graph.json

# 4. Validate graph
cd .project-graph && python3 graph_utils.py

# 5. Stage all changes
git add telegram_bot_stack/ .project-graph/

# 6. Commit
git commit -m "type(scope): description"

# Include graph update in commit message if significant:
# git commit -m "feat(storage): add Redis backend
#
# - Implemented RedisStorage class
# - Updated dependency graph with new module"
```

### Quick Reference: Graph Node Template

```json
{
"id": "telegram_bot_stack.module_name",
"name": "module_name",
"type": "module",
"category": "core|implementation|public_api",
"path": "telegram_bot_stack/module_name.py",
"description": "Brief description",
"lines_of_code": 0, // Run: wc -l file.py
"complexity_score": 5, // 1=simple, 10=complex
"exports": ["ClassName", "function_name"],
"imports": {
"internal": ["internal.Module"],
"external": ["external_lib"]
},
"dependencies": ["telegram_bot_stack.dependency"],
"dependents": [], // Will be filled by others
"tags": ["tag1", "tag2"],
"role": "What this module does",
"criticality": "low|medium|high|critical"
}
```

## ğŸ“‹ Detailed Rules (Reference)

**For complete rules, see archived version:**
- Git workflow details â†’ internal knowledge
- Cleanup procedures â†’ internal knowledge
- Documentation validation â†’ internal knowledge
- Code standards â†’ internal knowledge

**When needed, reference:**
- Conventional Commits: https://www.conventionalcommits.org/
- Pre-commit config: `.pre-commit-config.yaml`
- Test config: `pyproject.toml` [tool.pytest.ini_options]

---

**Remember:**
- ğŸ“‹ Read `.github/PROJECT_STATUS.md` first on every new context!
- ğŸ”— Update `.project-graph/dependency-graph.json` when changing `telegram_bot_stack/` structure!
- âœ… Validate graph before committing: `cd .project-graph && python3 graph_utils.py`
