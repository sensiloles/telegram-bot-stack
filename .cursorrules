# Cursor Agent Rules - telegram-bot-stack

## CRITICAL WORKFLOW (Always Follow This Order)

### 1. GitHub Flow - NEVER Push to Main
```bash
git branch --show-current # MUST NOT be 'main'
```

If on main â†’ create feature branch:
```bash
git checkout -b feature/<issue>-<name> # or fix/, docs/
```

main branch is **protected** - direct pushes will fail.

### 2. Graph Analysis - BEFORE Any Implementation

**ALWAYS load graphs before coding:**

```python
from utils.graph_utils import load_router, get_recommended_graph, load_graph_by_type

# Step 1: Load router
router = load_router() # 783 lines

# Step 2: Get recommendation for task
graph_file = get_recommended_graph(router, "your task")

# Step 3: Load specific domain
graph = load_graph_by_type('docs') # or 'bot_framework', 'testing', etc.
```

**Decision tree:**
- Framework code â†’ `load_graph_by_type('bot_framework')` â†’ `load_sub_graph('bot_framework', 'storage')`
- CI/CD, automation â†’ `load_graph_by_type('infrastructure')`
- Tests â†’ `load_graph_by_type('testing')`
- Documentation â†’ `load_graph_by_type('docs')`
- Build/config â†’ `load_graph_by_type('configuration')`
- History â†’ `load_graph_by_type('archive')`
- Examples â†’ `load_graph_by_type('examples')`

**Why:** 90-95% token savings. Read 900 lines instead of 10,000+.

See: `.project-graph/README.md` for complete guide.

### 3. Implementation

After loading relevant graph:
- Check dependencies/dependents in graph
- Understand impact (use `get_impact_analysis()`)
- Implement changes
- Write tests (>=80% coverage for `telegram_bot_stack/`)

### 4. Graph Update - AFTER Code Changes (If Needed)

**When to update:**
- `telegram_bot_stack/` â†’ update `bot-framework/` graph
- `.github/workflows/` â†’ update `infrastructure/graph.json`
- `tests/` â†’ update `testing/graph.json`
- `examples/` â†’ update `examples/graph.json`
- `docs/` â†’ update `docs/graph.json`

**Skip update for:**
- Documentation-only changes
- Bug fixes without structure changes
- Minor refactoring within same module

**How to update:**
```bash
# Edit relevant graph in .project-graph/
# Update metadata.generated_at to current date
# Update node_count, edge_count if changed

# Validate
cd .project-graph && python3 utils/graph_utils.py
```

See: `.project-graph/README.md` â†’ "Maintenance" section for examples.

### 5. Commit & Push

```bash
git status
git add .
git commit -m "type(scope): description" # See Conventional Commits below
git push -u origin feature/<name>
```

### 6. Create PR (Automated)

```bash
python3 .github/workflows/scripts/create_pr.py --title "type(scope): description" --closes <issue>
```

### 7. Merge PR (One Command)

```bash
python3 .github/workflows/scripts/merge_pr.py --cleanup
```

---

## Project Context

**Name:** telegram-bot-stack
**Type:** Reusable Telegram bot framework (PyPI package)
**Repository:** https://github.com/sensiloles/telegram-bot-stack
**Phase:** Phase 2 - PyPI Publication
**Coverage:** 131 tests, 80% coverage

**Key Files:**
- Status: `.github/PROJECT_STATUS.md`
- Graphs: `.project-graph/` (8 domains, 100% coverage)
- Automation: `.github/workflows/scripts/` (16+ scripts)
- MCP Server: `scripts/mcp_github_server.py` (GitHub issues integration)
- Plan: `archive/PACKAGE_CONVERSION_PLAN_RU.md` (archived)

---

## Essential Commands

### Conventional Commits (REQUIRED)

Format: `type(scope): description`

**Version impact:**
- `feat:` â†’ MINOR bump (0.1.0 â†’ 0.2.0)
- `fix:` â†’ PATCH bump (0.1.0 â†’ 0.1.1)
- `feat!` or `BREAKING CHANGE:` â†’ MAJOR bump (0.x â†’ 1.0.0)
- `docs:`, `chore:`, `test:`, `refactor:` â†’ No bump

**Examples:**
```
feat(storage): add Redis backend
fix(auth): resolve token validation
docs(readme): update quickstart
```

### GitHub Automation

**Preferred: MCP Server (if configured)**
Use MCP tools for GitHub issues directly in chat:
- `list_issues` - List issues with filters
- `get_issue` - Get issue details
- `create_issue` - Create new issue
- `update_issue` - Update labels, priority, comments, state

**Fallback: CLI Scripts**
```bash
python3 .github/workflows/scripts/read_issues.py --list --state open
python3 .github/workflows/scripts/create_issue.py --title "Bug: X" --labels bug
python3 .github/workflows/scripts/update_issue.py <N> --set-priority high
python3 .github/workflows/scripts/create_pr.py --title "feat: X" --closes <N>
python3 .github/workflows/scripts/merge_pr.py --cleanup
```

See: `.github/workflows/scripts/README.md` for all 16+ scripts.
MCP Setup: `docs/mcp-github-setup.md`

### Testing

```bash
python3 -m pytest
python3 -m pytest --cov=telegram_bot_stack --cov-report=term
```

Threshold: >=80% for `telegram_bot_stack/`

---

## Code Quality Rules

### Security
- NEVER commit tokens/passwords
- Use `.env` (in `.gitignore`)

### Code Style
- All comments/docstrings in English
- Type hints for all new code
- Follow ruff linting (see `pyproject.toml`)
- Remove unused imports immediately

### Documentation
- UPDATE existing docs, don't create new `.md` files
- Update docs BEFORE committing code
- Keep examples executable
- Test instructions work "out of the box"

### Testing
- >=80% coverage for `telegram_bot_stack/`
- Write tests for all new features
- Use fixtures from `tests/conftest.py`

---

## Token Efficiency

**Multi-Graph System: 90-95% savings**

| Your Task | Load Graph | Tokens | Savings |
|--------------------|-------------------------|--------|---------|
| Add storage | bot-framework/storage | 435 | 96% |
| Fix CI | infrastructure/graph | 639 | 94% |
| Add tests | testing/graph | 539 | 95% |
| Update docs | docs/graph | 300 | 97% |
| Add dependency | configuration/graph | 200 | 98% |
| History | archive/graph | 250 | 98% |

**Always:**
1. Start with `graph-router.json` (783 lines)
2. Load ONLY relevant graph (200-900 lines)
3. Never read entire codebase (10,000+ lines)

---

## Agent Decision Tree

### On New Context:
1. Read `.github/PROJECT_STATUS.md` (20 lines)
2. Check open issues: Use MCP `list_issues` tool (or `read_issues.py --list --state open`)
3. Verify branch: `git branch --show-current` (NOT main)
4. Load relevant graph from `.project-graph/`
5. Implement following workflow above

### On "Continue Work":
1. Check `PROJECT_STATUS.md`
2. List open issues: Use MCP `list_issues` â†’ identify active
3. Read issue details: Use MCP `get_issue <N>`
4. Check current branch
5. Load relevant graph
6. Implement â†’ test â†’ commit â†’ push â†’ PR

### Branch Strategy:
- On main? â†’ Create `feature/<issue>-<name>`
- On feature branch? â†’ Continue work
- Multiple features? â†’ Ask user about separate branches

### Commit Strategy:
- One commit per logical unit
- Batch related changes (docs + tests together)
- Update graphs in same commit as code changes

---

## Reference Links

**Detailed guides:**
- Multi-Graph System: `.project-graph/README.md`
- GitHub Automation: `.github/workflows/scripts/README.md`
- MCP Setup: `docs/mcp-github-setup.md`
- PR Automation: `.github/PR_AUTOMATION.md`
- Architecture: `README.md` (lines 155-250)
- Testing: `README.md` (lines 80-154)

**Configuration:**
- Conventional Commits: https://www.conventionalcommits.org/
- Pre-commit hooks: `.pre-commit-config.yaml`
- Pytest config: `pyproject.toml` â†’ `[tool.pytest.ini_options]`
- Ruff config: `pyproject.toml` â†’ `[tool.ruff]`

**Project files:**
- Status: `.github/PROJECT_STATUS.md`
- Plan (archived): `archive/PACKAGE_CONVERSION_PLAN_RU.md`
- Changelog: `CHANGELOG.md`

---

## Quick Examples

### Example 1: Add new storage backend

```python
# 1. Load storage sub-graph
storage = load_sub_graph('bot_framework', 'storage')
base = find_node(storage, 'telegram_bot_stack.storage.base')

# 2. Implement: telegram_bot_stack/storage/redis.py

# 3. Update graph: bot-framework/storage-graph.json
# Add node, edges, update metadata

# 4. Validate
cd .project-graph && python3 utils/graph_utils.py

# 5. Commit
git add telegram_bot_stack/storage/redis.py .project-graph/
git commit -m "feat(storage): add Redis backend"
```

### Example 2: Update documentation

```python
# 1. Load docs graph
docs = load_graph_by_type('docs')
api_ref = find_node(docs, 'docs.api_reference')

# 2. Edit: docs/api_reference.md

# 3. No graph update needed (docs only)

# 4. Commit
git commit -m "docs(api): update storage backend examples"
```

### Example 3: Fix CI pipeline

```python
# 1. Load infrastructure graph
infra = load_graph_by_type('infrastructure')

# 2. Find relevant workflow/script
# Edit: .github/workflows/tests.yml

# 3. Update graph if structure changed
# Edit: infrastructure/graph.json

# 4. Commit
git commit -m "fix(ci): resolve test timeout issue"
```

---

## Maintenance

### Check Before Writing Code:
```bash
ls .github/workflows/scripts/ # 16+ automation scripts exist
```

Use existing tools instead of ad-hoc PyGithub code.

### File Size Policy:
This file (.cursorrules) target: <400 lines
Current: ~350 lines âœ“

When updating:
1. Add new critical rule
2. Remove compensating verbose content
3. Verify: `wc -l .cursorrules`
4. Reference external docs instead of duplicating

Goal: Maximum density, minimum tokens, zero ambiguity.

---

## Summary Checklist

Before EVERY implementation:
- [ ] Check branch (not main)
- [ ] Check open issues (MCP `list_issues` or CLI)
- [ ] Load graph-router.json
- [ ] Load relevant domain graph
- [ ] Understand dependencies/impact

After implementation:
- [ ] Update graph if structure changed
- [ ] Validate: `python3 utils/graph_utils.py`
- [ ] Write/update tests (>=80% coverage)
- [ ] Update docs if needed
- [ ] Commit with conventional format
- [ ] Push + auto-create PR

On merge:
- [ ] Run `merge_pr.py --cleanup`
- [ ] Verify release triggered
- [ ] Check CI passed

**Remember:** GitHub Flow â†’ Graph Analysis â†’ Implementation â†’ Graph Update â†’ Commit â†’ PR â†’ Merge

---

## Documentation Style Rules

### Emoji Usage
- Use emoji in documentation ONLY when necessary for visual navigation
- Maximum 1 emoji per section header in README files
- NO emoji in code comments, docstrings, or commit messages
- NO emoji in .cursorrules or technical configuration files
- Acceptable: Section markers in user-facing docs (ðŸ“– Documentation, ðŸš€ Quick Start)
- Not acceptable: Decorative emoji, multiple emoji per line, emoji in explanations

**Rationale:** Emoji consume 3-4 bytes each, reduce readability in terminals, and add no semantic value to technical content.
